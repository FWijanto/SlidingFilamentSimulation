r[s_, p_] := 
 MapThread[
  If[Abs[#1] <= (k0 + 1)/
     2, #2*\[CapitalDelta]t0*2 E^(-(energyconstant/4))*
     E^(-((energyconstant*#1^2)/(1 + k0)))*Cosh[#1*energyconstant], 
    1] &, {s, p}](*k^-\[Times]\[CapitalDelta]t0*)

g[s_, p_] := (1 - p)*\[CapitalDelta]t0*kon/2*
  timeconstant*(Erf[(s + 0.5)*Sqrt[energyconstant]] - 
    Erf[(s - 0.5)*Sqrt[
      energyconstant]])(*k^+\[Times]\[CapitalDelta]t0*)(*Integrate[\
\[ExponentialE]^(-0.5 xsurdelta^2),{xsurdelta,s/\[Delta]-0.5,s/\
\[Delta]+0.5}]*)

neighbourtest[criterion_] := 
  Module[{n = 0}, 
   While[(g[d0*(0.5 + n), 0]/g[0, 0]) > criterion, n++]; n];
swrapped[s_] := Mod[s, d0, -d0/2];
positionslistplus[s_] := Prepend[
   Table[i*d0 - s
    , {i, neighbourtest[neighbourcriterion]}
    ]
   , s];
positionslistminus[s_] := Prepend[
   Table[i*d0 + s
    , {i, neighbourtest[neighbourcriterion] - 2}]
   , Last[positionslistplus[s]]];
attachmentfunctionplus[s_, p_] := 
  If[neighbourtest[neighbourcriterion] > 1,
   Total[
    Table[
      i*(1 - Unitize[p]), {i, 2, 
       neighbourtest[neighbourcriterion] + 1}]*MapThread[
      (MapThread[(Boole[#1 > #2]) &, {r1, #1}]*
         MapThread[(Boole[#1 < #2]) &, {r1, #2}]) &
      , Transpose[
       Partition[
        Accumulate[
         Map[
          g[#, p] &, positionslistplus[s]]
         ]
        , 2, 1]
       ]
      ]
    ]
   , 0];
attachmentfunctionminus[s_, p_] := 
  If[neighbourtest[neighbourcriterion] > 2,
   Total[
    Table[-i*(1 - Unitize[p]), {i, 1, 
       neighbourtest[neighbourcriterion] - 2}]*MapThread[
      (MapThread[(Boole[#1 > #2]) &, {r1, #1}]*
         MapThread[(Boole[#1 < #2]) &, {r1, #2}]) &
      , Transpose[
       Partition[
        Accumulate[
         Map[
          g[#, p] &, positionslistminus[s]]
         ]
        , 2, 1]
       ]
      ]
    ]
   , 0];
cumulativeprob[s_, p_] := If[neighbourtest[neighbourcriterion] > 2,
   Last[
    Accumulate[
     Map[
      g[#, p] &, positionslistminus[s]]
     ]
    ]
   , If[neighbourtest[neighbourcriterion] > 1,
    Last[
     Accumulate[
      Map[
       g[#, p] &, positionslistplus[s]]
      ]
     ], g[swrapped[s], p]]];

trajectorybindingstate[x_] := 
  Table[{pathvector[[2, 1, i, 1]], pathvector[[2, 1, i, 2, x]]}, {i, 
    Nrealisation + 1}];
trajectoryload[x_] := 
  Table[{pathvector[[2, 1, i, 1]], pathvector[[2, 1, i, 3, x]]}, {i, 
    Nrealisation + 1}];
trajectoryloadvsdisplacement[x_] := 
  Table[{prescribeddisplacementlinear[[i]], 
    pathvector[[2, 1, i, 3, x]]}, {i, Nrealisation + 1}];
cycletrajectorybindingstate[x_] := 
  Table[{cyclepathvector[[2, 1, i, 1]], 
    cyclepathvector[[2, 1, i, 2, x]]}, {i, 
    Length[cyclepathvector[[2, 1]]]}];
cycletrajectoryload[x_] := 
  Table[{cyclepathvector[[2, 1, i, 1]], 
    cyclepathvector[[2, 1, i, 3, x]]}, {i, 
    Length[cyclepathvector[[2, 1]]]}];
cycletrajectoryloadvsdisplacement[x_] := 
  Table[{prescribeddisplacementcycle[[i]], 
    cyclepathvector[[2, 1, i, 3, x]]}, {i, 
    Length[cyclepathvector[[2, 1]]]}];
averageloadextractor[x_, averagestartpoint_(*en s*), 
   averageendpoint_(*en s*)] := {Mean[
    Transpose[
      x[[IntegerPart[averagestartpoint/\[CapitalDelta]t0 + 1] ;; 
        IntegerPart[averageendpoint/\[CapitalDelta]t0 + 1]]]][[2]]], 
   StandardDeviation[
    Transpose[
      x[[IntegerPart[averagestartpoint/\[CapitalDelta]t0 + 1] ;; 
        IntegerPart[averageendpoint/\[CapitalDelta]t0 + 1]]]][[2]]]};